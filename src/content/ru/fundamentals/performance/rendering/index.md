project_path: /web/_project.yaml book_path: /web/fundamentals/_book.yaml description: Пользователи заметят, если сайты и приложения работают плохо, поэтому оптимизация производительности визуализации имеет важнейшее значение!

{# wf_updated_on: 2015-03-19 #} {# wf_published_on: 2000-01-01 #}

# Производительность визуализации {: .page-title }

Сегодняшние интернет-пользователи [хотят, чтобы открываемые ими страницы были интерактивными и работали плавно.](http://paul.kinlan.me/what-news-readers-want/) Именно этому и требуется уделять много времени и труда. Страницы должны не только быстро загружаться, но и работать хорошо: прокрутка должна быть быстрой, а анимация и взаимодействия – плавными

Users of today’s web [expect that the pages they visit will be interactive and smooth](https://paul.kinlan.me/what-news-readers-want/) and that’s where you need to increasingly focus your time and effort. Pages should not only load quickly, but also run well; scrolling should be stick-to-finger fast, and animations and interactions should be silky smooth.

Длятого чтобы писать производительные сайты и приложения, необходимо понимать, каким образом браузер обрабатывает HTML, JavaScript и CSS. А уже на основе этих знаний необходимо предпринять усилия, чтобы ваш код (а также сторонний код, который вы используете) работал как можно эффективнее.

## 60 кадров в секунду и частота обновления экрана устройства

<div class="attempt-right">
  <figure>
    <img src="images/intro/response.jpg" alt="User interacting with a website.">
  </figure>
</div>

Сегодня большинство устройств обновляют свои экраны **60 раз в секунду**. Если выполняется анимация или переход либо если пользователь прокручивает страницы, браузеру нужно соответствовать частоте обновления экрана устройства и выдавать по одной новой картинке (или кадру) при каждом обновлении экрана.

Каждый из этих кадров может длиться чуть более 16 мс (1 секунда / 60 = 16,66 мс). В реальности же браузеру нужно выполнить и еще кое-какие действия, потому вся ваша работа должна занимать не более **10 мс**. Если не уложиться в эти рамки, частота кадров будет меньше, а контент начнет дергаться на экране. Часто эту ситуацию называют **подвисанием**, она отрицательно сказывается на восприятии пользователей.

## Конвейер пикселей

Есть пять основных областей, о которых следует знать и помнить при выполнении своей работы. Это те области, которые вы в наибольшей степени контролируете. Они являются ключевыми точками конвейера вывода пикселей на экран.

<img src="images/intro/frame-full.jpg"  alt="Полный конвейер пикселей" />

* **JavaScript**. Обычно JavaScript используется для выполнения работы, результатом которой будут визуальные изменения, будь то функция jQuery `animate`, сортировка набора данных или добавление DOM-элементов на страницу. Однако вызывать визуальное изменение можно не только с помощью JavaScript: Также часто используются анимация CSS, переходы и API-интерфейс веб-анимации.
* **Вычисление стилей**. В процессе вычисления стилей определяется, какие правила CSS к каким элементам применяются с учетом соответствующих селекторов, например: `.headline` или `.nav > .nav__item`. Отсюда, после того как правила определены, они применяются и вычисляются итоговые стили для каждого элемента.
* **Расчет макета**. Как только браузер будет знать, какие правила применяются к элементу, он может начать вычислять, сколько места он займет, и где он находится на экране. Модель макета для Интернета означает, что один элемент может влиять на другие, например: ширина элемента `<body>` обычно влияет на значения ширины дочерних элементов и так далее по всему дереву, поэтому этот процесс для браузера может быть довольно сложным.
* **Прорисовка**. Прорисовка – это процесс заполнения пикселей. Он подразумевает вывод текста, цветов, изображений, границ и теней, по сути – всех визуальных частей элементов. Прорисовка обычно выполняется на нескольких поверхностях, которые называются слоями.
* **Компоновка**. Поскольку части страницы потенциально были прорисованы на нескольких слоях, они должны быть выведены на экран в надлежащем порядке, с тем чтобы страница отображалась правильно. Это особенно важно для элементов, которые перекрывают другие элементы, поскольку ошибка может привести к тому, что один элемент будет неправильно показан поверх другого элемента.

Каждая из этих частей конвейера является потенциальным источником подвисания. Поэтому важно точно понимать, какие части конвейера срабатывают при выполнении вашего кода.

Note: Иногда, когда речь идет о прорисовке, можно услышать термин 'растеризовать'. Связано это с тем, что прорисовка, по сути, состоит из двух операций: 1) создания списка команд draw call и 2) заполнения пикселей. Последняя операция называется 'растеризацией', поэтому, когда вы видите записи о прорисовке в DevTools, это означает, что также подразумевается и растеризация. (В некоторых вариантах архитектуры создание списка команд draw call и растеризация выполняются в разных потоках, однако разработчик не может этого контролировать.)

Далеко не всегда каждый кадр затрагивает все части конвейера. На самом деле есть три варианта, в соответствии с которыми конвейер*обычно* воспроизводится для данного кадра при внесении визуального изменения, – с помощью JavaScript, CSS или веб-анимации:

You won’t always necessarily touch every part of the pipeline on every frame. In fact, there are three ways the pipeline *normally* plays out for a given frame when you make a visual change, either with JavaScript, CSS, or Web Animations:

### 1. JS / CSS > Стиль > Расчет макета > Прорисовка > Компоновка

<img src="images/intro/frame-full.jpg"  alt="The full pixel pipeline" />

If you change a “layout” property, so that’s one that changes an element’s geometry, like its width, height, or its position with left or top, the browser will have to check all the other elements and “reflow” the page. Any affected areas will need to be repainted, and the final painted elements will need to be composited back together.

### 2. JS / CSS > Стиль > Прорисовка > Компоновка

<img src="images/intro/frame-no-layout.jpg" alt="The  pixel pipeline without layout." />

If you changed a “paint only” property, like a background image, text color, or shadows, in other words one that does not affect the layout of the page, then the browser skips layout, but it will still do paint.

### 3. JS / CSS > Стиль > Компоновка

<img src="images/intro/frame-no-layout-paint.jpg" alt="The pixel pipeline without layout or paint." />

Последний вариант является самым простым и наиболее предпочтительным для точек высокой нагрузки в жизненном цикле приложения, например при анимации или прокрутке.

Note: Если вы желаете узнать, какие из приведенных выше трех вариантов вызовут изменение того или иного свойства CSS, читайте статью [Срабатывание событий при изменении CSS](http://csstriggers.com). Если вы сразу хотите узнать, как создавать высокопроизводительную анимацию, прочитайте раздел об [изменении свойств, которые затрагивают только компоновку](stick-to-compositor-only-properties-and-manage-layer-count).

Производительность – это искусство избегать работы и делать любую работу как можно более эффективно. Во многих случаях это означает работу вместе с браузером, а не против него. Стоит помнить, что описанная выше работа в конвейере отличается по затратам вычислительных ресурсов: одни задачи являются более ресурсоемкими, чем другие!

Давайте разберемся с разными частями конвейера. Мы рассмотрим стандартные проблемы, а также методы их диагностики и устранения.

{% include "web/_shared/udacity/ud860.html" %}

{% include "web/_shared/udacity/ud860.html" %}

## Feedback {: #feedback }

{% include "web/_shared/helpful.html" %}