project_path: /web/_project.yaml book_path: /web/fundamentals/_book.yaml description: Изображения - те ресурсы, которые часто занимают много места на странице и весят больше всего. Благодаря их оптимизации мы можем значительно уменьшить количество скачиваемых данных и улучшить работу сайта. Чем больше сжато изображение, тем меньше пропускной способности канала занимает скачивание и тем быстрее браузер сможет показать страницу пользователю.

{# wf_updated_on: 2014-05-09 #} {# wf_published_on: 2014-05-06 #}

# Оптимизация изображений {: .page-title }

{% include "web/_shared/contributors/ilyagrigorik.html" %}

Изображения - те ресурсы, которые часто занимают много места на странице и весят больше всего. Благодаря их оптимизации мы можем значительно уменьшить количество скачиваемых данных и улучшить работу сайта. Чем больше сжато изображение, тем меньше пропускной способности канала занимает скачивание и тем быстрее браузер сможет показать страницу пользователю.

Оптимизация изображений - это одновременно наука и искусство. Мы можем назвать это искусством, потому что никто не может дать определенный ответ, как лучше всего сжать конкретное изображение. Однако это и наука, ведь в нашем распоряжении есть разработанные техники и алгоритмы, которые могут значительно уменьшить размер ресурса. Чтобы выбрать оптимальные настройки для изображения, необходимо учесть много факторов: возможности формата, закодированные данные, качество, количество пикселей и т. д.

## Удаление и замена изображений

### TL;DR {: .hide-from-toc }

* Удалите ненужные изображения.
* При возможности применяйте эффекты CSS3.
* Используйте веб-шрифты вместо кодировки текста в изображениях.

Прежде всего задайте себе вопрос: действительно ли это изображение необходимо? Хороший дизайн должен быть простым и не ухудшать производительность. Лучше всего просто удалить ненужное изображение, поскольку оно весит гораздо больше байтов по сравнению с HTML, CSS, JavaScript и другими ресурсами на странице. При этом одно изображение в нужном месте может заменить длинный текст, поэтому вам нужно самостоятельно найти баланс и принять правильное решение.

После этого вы должны проверить, нельзя ли достигнуть желаемого результата более эффективным путем:

* Благодаря **CSS-эффектам** (градиентам, теням и т. д.) и CSS-анимации вы можете создать ресурсы, которые четко выглядят при любом разрешении и масштабе и весят гораздо меньше, чем изображения.
* **Веб-шрифты** позволяют использовать красивые надписи, сохраняя возможность выбирать и искать текст, а также менять его размер. Благодаря этому работа с вашим ресурсом станет ещё удобнее.

Избегайте кодирования текста в изображении. Красивые надписи необходимы для качественного дизайна, продвижения бренда и удобной работы с ресурсом, но текст в изображении только мешает всему этом. Его нельзя выбрать, найти, увеличить, скопировать, а также он плохо смотрится на устройствах с высоким разрешением. Конечно, веб-шрифтам также требуется оптимизация, но они помогут избежать вышеперечисленных проблем. Для отображения текста всегда выбирайте именно их.

## Векторные и растровые изображения

### TL;DR {: .hide-from-toc }

* Векторный формат отлично подходит для изображений из геометрических фигур.
* Качество векторных изображений не зависит от масштаба и разрешения.
* Используйте растровый формат для сложных изображений с множеством нестандартных форм и деталей.

Если вы решили, что для достижения результата вам следует использовать именно изображение, выберите для него подходящий формат:

<div class="attempt-left">
  <figure>
    <img src="images/vector-zoom.png" alt="Увеличенное растровое изображение">
    <figcaption>Векторное изображение</figcaption>
  </figure>
</div>

<div class="attempt-right">
  <figure>
    <img src="images/raster-zoom.png" alt="Увеличенное растровое изображение">
    <figcaption>Растровое изображение</figcaption>
  </figure>
</div>

<div style="clear:both;"></div>

* В [векторной графике](http://ru.wikipedia.org/wiki/Векторная_графика) для отображения картинки используются линии, точки и многоугольники.
* В [растровой графике](http://ru.wikipedia.org/wiki/Растровая_графика) индивидуальные значения каждого пикселя в прямоугольной сетке кодируются, и на их основе показывается изображение.

Each format has its own set of pros and cons. Vector formats are ideally suited for images that consist of simple geometric shapes (for example, logos, text, icons, and so on), and deliver sharp results at every resolution and zoom setting, which makes them an ideal format for high-resolution screens and assets that need to be displayed at varying sizes.

У каждого формата есть свои достоинства и недостатки. Векторный формат идеально подходит для изображений из простых геометрических фигур (например, логотипов, текста, значков и т. д.). Они остаются четкими при любом разрешении и масштабе, поэтому используйте этот формат для больших экранов и ресурсов, которые должны быть показаны в разных размерах.

Однако векторные форматы не подходят для сложных изображений (например, для фотографий). SVG-разметки для описания всех фигур может стать слишком много, но полученное изображение все равно будет выглядеть нереалистично. В этом случае вам стоит использовать растровый формат изображений, например GIF, PNG, JPEG или новые форматы JPEG-XR и WebP.

## Оптимизация для экранов с высоким разрешением

### TL;DR {: .hide-from-toc }

* На экранах с высоким разрешением один CSS-пиксель состоит из нескольких экранных пикселей.
* В изображениях высокого разрешения пикселей и байтов гораздо больше, чем в обычных.
* Техники оптимизации можно применять к изображениям любого разрешения.

Качество растровых изображений зависит от разрешения и масштаба: при увеличении оно становится размытым и распадается на пиксели. В результате вам может понадобиться сохранить несколько версий растрового изображения в разных разрешениях.

<img src="images/css-vs-device-pixels.png"  alt="CSS vs device pixels" />

High DPI (HiDPI) screens produce beautiful results, but there is one obvious tradeoff: our image assets require more detail in order to take advantage of the higher device pixel counts. The good news is, vector images are ideally suited for this task, as they can be rendered at any resolution with sharp results - we might incur a higher processing cost to render the finer detail, but the underlying asset is the same and is resolution independent.

Конечно, на экранах с высоким DPI (HiDPI) графика выглядит очень красиво. Однако, чтобы хорошо смотреться в высоком разрешении, наши изображения должны быть более детализированными. Но у нас есть решение: векторные форматы идеально подходят для этой задачи. Они сохраняют четкость в любом разрешении. Даже если увеличатся затраты на отрисовку мелких деталей, мы по-прежнему используем один независимый от размера экрана ресурс.

<table>
  
<thead>
  <tr>
    <th>Разрешение экрана</th>
    <th>Всего пикселей</th>
    <th>Размер файла без сжатия (4 Б на пикс.)</th>
  </tr>
</thead>

<tr>
  <td data-th="resolution">1x</td>
  <td data-th="total pixels">100 x 100 = 10 000</td>
  <td data-th="filesize">40 000 Б</td>
</tr>
<tr>
  <td data-th="resolution">2x</td>
  <td data-th="total pixels">100 x 100 x 4 = 40 000</td>
  <td data-th="filesize">160 000 Б</td>
</tr>
<tr>
  <td data-th="resolution">3x</td>
  <td data-th="total pixels">100 x 100 x 9 = 90 000</td>
  <td data-th="filesize">360 000 Б</td>
</tr>
</table>

С другой стороны, с растровыми изображениями возникает гораздо больше сложностей, потому что они кодируют данные изображения в каждом пикселе. Таким образом, чем выше число пикселей, тем больше размер такого ресурса. В качестве примера рассмотрим разницу между фотографиями размером 100х100 CSS-пикселей:

Когда мы вдвое увеличиваем разрешение экрана, общее количество пикселей возрастает сразу в четыре раза: в два раза по вертикали и в два по горизонтали.

## Оптимизация векторных изображений

### TL;DR {: .hide-from-toc }

* SVG - это формат изображений на основе XML
* SVG-файлы нужно минифицировать для уменьшения размера.
* Сжимайте SVG-файлы с помощью GZIP.

Подведем итог. На экранах с большим разрешением графика выглядят очень привлекательно, поэтому вы сможете создать хорошее впечатление о вашем сайте. Однако для таких экранов нужны изображения с высоким разрешением. Выбирайте векторные форматы, потому что они четко выглядят на любых устройствах. Если необходимо использовать растровое изображение, добавьте несколько оптимизированных вариантов ресурса (см. далее).

    <?xml version="1.0" encoding="utf-8"?>
    <!-- Generator: Adobe Illustrator 17.1.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
    <svg version="1.2" baseProfile="tiny" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
       x="0px" y="0px" viewBox="0 0 612 792" xml:space="preserve">
    <g id="XMLID_1_">
      <g>
        <circle fill="red" stroke="black" stroke-width="2" stroke-miterlimit="10" cx="50" cy="50" r="40"/>
      </g>
    </g>
    </svg>
    

Все современные браузеры поддерживают формат SVG (Scalable Vector Graphics). Это формат изображений на основе XML для двухмерной графики. Разметку SVG можно встроить прямо в страницу или на внешний ресурс. В свою очередь, файл SVG можно создать с помощью любого ПО для векторного рисования или вручную в текстовом редакторе.

Пример выше отрисовывает простую круглую форму с черной границей и красным фоном. Она была экспортирована из Adobe Illustrator. Легко догадаться, что она содержит множество метаданных, например информацию о слоях, комментарии и пространства имен XML, которые чаще всего не нужны для отобрадения ресурса в браузере. В результате, следует минифицировать файлы SVG с помощью инструмента [svgo](https://github.com/svg/svgo).

## Оптимизация растровых изображений

### TL;DR {: .hide-from-toc }

* Растровое изображение - это сетка пикселей.
* В каждом пикселе закодирована информация о цвете и прозрачности.
* Чтобы уменьшить размер изображения, компрессоры используют различные методы для снижения количества битов на пиксель.

Например, svgo уменьшает размер приведенного выше файла SVG на 58% с 470 до 199 Б. Кроме того, поскольку SVG - это формат на основе XML, мы может применить сжатие GZIP для уменьшения его размера при передаче. Убедитесь, что на вашем сервере настроено сжатие SVG-ресурсов.

Растровое изображение - это просто двухмерная сетка отдельных `пикселей`. Например, изображение 100x100 пикселей - это последовательно из 10 000 пикселей. В каждом из пикселей содержатся значения RGBA: красного (R), зеленого (G) и синего (B) канала, а также альфа-канала, или канала прозрачности (A).

* Изображение 100 x 100 пикс. состоит из 10 000 пикселей
* 10 000 пикс. x 4 Б = 40 000 Б
* 40 000 Б / 1024 = 39 КБ

Браузер устанавливает 256 значений (оттенков) для каждого канала, которые в пере счете занимают 8 битов на канал (2 ^ 8 = 256) и 4 байта на пиксель (4 канала x 8 бит = 32 бита = 4 байта). Таким образом, зная размеры сетки, мы легко можем вычислить размер файла:

<table>
  
<thead>
  <tr>
    <th>Размер</th>
    <th>Пиксели</th>
    <th>Размер файла</th>
  </tr>
</thead>

<tr>
  <td data-th="dimensions">100 x 100</td>
  <td data-th="pixels">10 000</td>
  <td data-th="file size">39 КБ</td>
</tr>
<tr>
  <td data-th="dimensions">200 x 200</td>
  <td data-th="pixels">40 000</td>
  <td data-th="file size">156 КБ</td>
</tr>
<tr>
  <td data-th="dimensions">300 x 300</td>
  <td data-th="pixels">90 000</td>
  <td data-th="file size">351 КБ</td>
</tr>
<tr>
  <td data-th="dimensions">500 x 500</td>
  <td data-th="pixels">250 000</td>
  <td data-th="file size">977 КБ</td>
</tr>
<tr>
  <td data-th="dimensions">800 x 800</td>
  <td data-th="pixels">640 000</td>
  <td data-th="file size">2500 КБ</td>
</tr>
</table>

39KB for a 100x100 pixel image may not seem like a big deal, but the filesize quickly explodes for larger images and makes image assets both slow and expensive to download. Thankfully, what we've described so far is the "uncompressed" image format. What could we do to reduce the image file size?

Note: Кроме того, вне зависимости от формата изображения, передаваемого от сервера клиенту, при расшифровке изображения каждый пиксель занимает 4 байта памяти. Поэтому при отображении больших файлов на устройствах с ограниченным количеством памяти могут возникнуть проблемы.

<img src="images/artifacts.png"  alt="Compression artifacts" />

Один из простых способов оптимизации изображения - снизить глубину цвета с 8 битов на канал, выбрав палитру меньшего размера. Установив глубину в 8 битов на канал, мы получаем 256 значений для канала и 16 777 216 (2563) цветов. Может, стоит уменьшить палитру до 256 цветов? Тогда нам будет нужно всего 8 бит для всех каналов RGB и только 2 байта на пиксель, а не 4, как раньше. Нам удалось сжать изображения в два раза!

Next, once we've optimized the data stored in individual pixels we could get more clever and look at nearby pixels as well: turns out, many images, and especially photos, have many nearby pixels with similar colors - for example, the sky, repeating textures, and so on. Using this information to our advantage the compressor can apply "[delta encoding](https://en.wikipedia.org/wiki/Delta_encoding)" where instead of storing the individual values for each pixel, we can store the difference between nearby pixels: if the adjacent pixels are the same, then the delta is "zero" and we only need to store a single bit! But why stop there...

Note: Изображения в формате PNG слева направо: 32 бита (16M цветов), 7 бит (128 цветов), 5 бит (32 цвета). Сложные изображения с плавными перехода цвета (градиентами, небом и т. д.) требуют палитр большего размера. Однако если ресурс состоит из небольшого количества цветов, большая палитра - это напрасная трата битов.

Оптимизировав данные в отдельных пикселях, обратим внимания на соседние пиксели. Оказывается, цвет таких пикселей на многих изображениях, особенно на фотографиях, часто похож. Благодаря этому компрессор может применять [дельта-кодирование](http://ru.wikipedia.org/wiki/Дельта-кодирование). Вместо сохранения отдельных значения для каждого пикселя можно указать только разницу между соседними пикселями. Если они одинаковы, то дельта равна нулю, и нам нужно сохранить всего один бит. Но это ещё не все!

Мы часто не замечаем разницы в некоторых оттенках, поэтому мы можем оптимизировать изображение, уменьшив или увеличив палитру для этих цветов. У каждого пикселя в двухмерной сетке есть несколько `соседей`, поэтому мы можем усовершенствовать дельта-кодирование. Сконцентрируетесь не на непосредственных соседях пикселя, а на целых блоках похожих цветов и закодируйте их с помощью разных настроек.

## Сжатие данных с потерями и без потерь

### TL;DR {: .hide-from-toc }

* Учитывая особенности человеческого зрения, для изображений можно применять сжатие данных с потерями.
* Для оптимизации изображения используется сжатие данных с потерями и без потерь.
* Разница в форматах изображений - это отличия в том, как и какие алгоритмы этих сжатий применяются для уменьшения размера ресурса.
* Не существует самого лучшего формата или настройки качества, которые подошли бы для всех изображений. При сочетании разных компрессоров и ресурсов мы никогда не получим одинаковый результат.

Как вы видите, оптимизация изображения становится все сложнее и интереснее. На эту тему ведутся научные и коммерческие исследования, потому что изображения весят много байтов, и развивать новые техники сжатия выгодно. Если вы хотите узнать больше, прочитайте [статью на Википедии](http://ru.wikipedia.org/wiki/Сжатие_изображений) или ознакомьтесь с конкретными примерами в [брошюре о техниках сжатия WebP](/speed/webp/docs/compression).

Итак, как весь этот сложный материал поможет нам оптимизировать изображения? Повторим: нам не нужно изобретать новые методы сжатия. Однако нам нужно знать о ключевых аспектах вопроса: пикселях RGBA, глубине цвета и разных техниках оптимизации. Это необходимо, чтобы продолжить разговор о растровых форматах.

1. Сжатие изображения `[с потерями](http://ru.wikipedia.org/wiki/Сжатие_данных_с_потерями)`, при котором удаляются некоторые данные пикселей.
2. Сжатие изображения `[без потерь](http://en.wikipedia.org/wiki/Lossless_compression)`, при котором данные пикселей сжимаются.

Для определенных типов данных, например исходного кода страницы или исполняемого файла, крайне важно, чтобы компрессор не удалял и не менял первоначальную информацию. Из-за пропавшего или неправильного бита данных может быть полностью искажено или уничтожено значение контента файла. Однако другие типы данных вполне можно передать в `приблизительном` виде.

Из-за особенностей человеческого зрения мы можем не заметить отсутствия какой-либо информации о каждом пикселе, например мы не увидим различия между некоторыми оттенками цвета. Поэтому мы можем использовать меньше битов для кодирования некоторых цветов и благодаря этому уменьшить размер ресурса. Таким образом, стандартная оптимизация изображения состоит из двух основных этапов:

<img src="images/save-for-web.png" class="attempt-right" alt="Save for web" />

Как лучше всего совмещать сжатие с потерями и без потерь? Это зависит от самого изображения и других условий, например баланса между размером файла и шумами. Чтобы получить четкое детализированное изображение, вы можете не применять сжатие с потерями. Если же для вас больше важен размер файла, смело используйте этот метод оптимизации. Единого варианта настроек для всех изображений не существует. Вы сами должны определить желаемый результат и принять решение.

Note: Note that quality levels for different image formats are not directly comparable due to differences in algorithms used to encode the image: quality 90 JPEG will produce a very different result than a quality 90 WebP. In fact, even quality levels for the same image format may produce visibly different output based on implementation of the compressor!

## Выбор формата изображения

### TL;DR {: .hide-from-toc }

* Выберите подходящий стандартный формат: GIF, PNG или JPEG.
* Попробуйте установить разные настройки для каждого формата (качество, размер палитры и т. д.) и выберите наиболее подходящие.
* Для современных клиентов добавьте ресурсы в форматах WebP и JPEG XR масштабированные изображения:

При использовании сжатия с потерями, например JPEG, вы сможете выбрать настройки качества (вроде ползунка `Сохранить для Web` в Adobe Photoshop). Обычно это значение от 1 до 100, которое определяет применение алгоритмов сжатия с потерями и без. Не бойтесь снижать качество: часто изображение по-прежнему хорошо выглядит, а размер файла становится значительно меньше.

<table>
  
<thead>
  <tr>
    <th>Формат</th>
    <th>Прозрачность</th>
    <th>Анимация</th>
    <th>Браузер</th>
  </tr>
</thead>

<tr>
  <td data-th="format"><a href="http://en.wikipedia.org/wiki/Graphics_Interchange_Format">GIF</a></td>
  <td data-th="transparency">Да</td>
  <td data-th="animation">Да</td>
  <td data-th="browser">Все</td>
</tr>
<tr>
  <td data-th="format"><a href="http://en.wikipedia.org/wiki/Portable_Network_Graphics">PNG</a></td>
  <td data-th="transparency">Да</td>
  <td data-th="animation">Нет</td>
  <td data-th="browser">Все</td>
</tr>
<tr>
  <td data-th="format"><a href="http://en.wikipedia.org/wiki/JPEG">JPEG</a></td>
  <td data-th="transparency">Нет</td>
  <td data-th="animation">Нет</td>
  <td data-th="browser">Все</td>
</tr>
<tr>
  <td data-th="format"><a href="http://en.wikipedia.org/wiki/JPEG_XR">JPEG XR</a></td>
  <td data-th="transparency">Да</td>
  <td data-th="animation">Да</td>
  <td data-th="browser">IE</td>
</tr>
<tr>
  <td data-th="format"><a href="http://en.wikipedia.org/wiki/WebP">WebP</a></td>
  <td data-th="transparency">Да</td>
  <td data-th="animation">Да</td>
  <td data-th="browser">Chrome, Opera, Android</td>
</tr>
</table>

Note: Обратите внимание, изображения с одинаковыми настройками качества, но в разных форматах будут отличаться. Это происходит из-за разницы в алгоритмах сжатия изображения. Например, JPEG и WebP с настройками качества 90 выглядят по-разному. На самом деле, даже изображения в одном формате и с одинаковыми настройками качества могут отличаться в зависимости от использованного компрессора.

<img src="images/format-tree.png"  alt="Save for web" />

1. **Изображение должно быть анимированным? Тогда выбирайте формат GIF.** 
    * Цветовая палитра GIF состоит всего из 256 цветов. Это недостаточно для большинства изображений. Кроме того, формат PNG-8 лучше сжимает изображения с маленькой палитрой. Таким образом, выбирайте GIF, только если вам требуется анимация.
2. **Нужно сохранить все мелкие детали в самом высоком разрешении? Используйте PNG.** 
    * В формате PNG не применяется сжатие с потерей данных, не считая выбора размера палитры. Благодаря этому изображение сохраняется в самом высоком качестве, но весит гораздо больше, чем файлы других форматов. Используйте этот формат только там, где это необходимо.
    * Если изображение состоит из геометрических фигур, конвертируйте его в векторный (SVG-) формат!
    * Избегайте текста в изображениях. Его нельзя выбрать, найти или увеличить. Если текст необходим для создания дизайна, используйте веб-шрифты.
3. **Вы оптимизируете фотографию, скриншот или изображение похожего типа? Используйте JPEG.** 
    * В JPEG используется комбинация сжатия с потерями и без потерь для уменьшения размера файла. Чтобы выбрать лучшее сочетание качества и размера изображения, попробуйте установить несколько уровней качества JPEG.

Существуют три стандартных формата изображений: GIF, PNG и JPEG. Кроме них некоторые браузеры поддерживают новые форматы WebP и JPEG XR, для которых доступно большее сжатие и дополнительные возможности. Итак, какой формат выбрать?

Since neither WebP and JPEG XR are universally supported, you will need to add additional logic to your application or servers to serve the appropriate resource:

* Некоторые сети доставки контента предоставляют услуги по оптимизации изображений, в том числе предоставление файлов в JPEG XR и WebP.
* Некоторые инструменты с открытым кодом, например PageSpeed для Apache и Nginx, автоматически производят оптимизацию, преобразование и доставку соответствующих ресурсов.
* Вы можете добавить дополнительную логику приложения, чтобы определить клиент и его поддерживаемые форматы, а затем отправить оптимальный вариант ресурса.

Определив подходящий формат и его настройки для всех ресурсов, добавьте дополнительный вариант в WebP и JPEG XR. Это новые форматы, которые пока не поддерживаются во всех браузерах. Однако с их помощью может значительно уменьшить размер файла. Например, WebP сжимает изображение на [30% ](/speed/webp/docs/webp_study) больше, чем JPEG.

## Инструменты и выбор параметров

Поскольку WebP and JPEG XR поддерживаются не во всех браузерах, вам надо добавить дополнительную логику в приложения или на серверы, чтобы отправлять пользователю соответствующий ресурс.

<table>
  
<thead>
  <tr>
    <th>Инструмент</th>
    <th>Описание</th>
  </tr>
</thead>

<tr>
  <td data-th="tool"><a href="http://www.lcdf.org/gifsicle/">gifsicle</a></td>
  <td data-th="description">создает и оптимизирует GIF-изображения</td>
</tr>
<tr>
  <td data-th="tool"><a href="http://jpegclub.org/jpegtran/">jpegtran</a></td>
  <td data-th="description">оптимизирует JPEG-изображения</td>
</tr>
<tr>
  <td data-th="tool"><a href="http://optipng.sourceforge.net/">optipng</a></td>
  <td data-th="description">сжимает PNG без потерь</td>
</tr>
<tr>
  <td data-th="tool"><a href="http://pngquant.org/">pngquant</a></td>
  <td data-th="description">сжимает PNG с потерями</td>
</tr>
</table>

Обратите внимание, что если вы используете Webview для отрисовки контента в нативное приложении, тогда вы можете полностью управлять клиентом и использовать только WebP. В приложениях Facebook, Google+ и т. д. используются именно WebP-ресурсы, так как они действительно повышают производительность. Чтобы узнать больше об этом формате, посмотрите презентацию [WebP: Deploying Faster, Smaller, and More Beautiful Images](https://www.youtube.com/watch?v=pS8udLMOOaE) от Google I/O 2013.

## Масштабирование передаваемых изображений

### TL;DR {: .hide-from-toc }

* **Выбирайте изображения в векторных форматах.** Их качество не зависит от разрешения и масштаба, поэтому они подходят для больших экранов и разных типов устройств.
* ** Минифицируйте и сжимайте SVG-ресурсы.** Многие графические приложения добавляют XML-разметку, которая часто содержит ненужные метаданные. Ее можно удалить. Убедитесь, что на серверах настроено GZIP-сжатие для SVG-ресурсов.
* **Выбирайте наиболее подходящие растровые форматы.** Определите необходимые требования к изображениям и выберите нужный формат для каждого ресурса.

Не существует одного идеального формата, инструмента или алгоритма оптимизации, который бы подошел бы для всех изображений. Чтобы получить наилучший результат, вы должны выбрать формат и его настройки в зависимости от контента, а также визуальных и технических требований.

<img src="images/resized-image.png" class="attempt-right" alt="Resized image" />

{# wf_TODO #} Warning: A tag here did NOT convert properly, please fix! ''

Размер изображения - это сумма пикселей, умноженная на число байтов, используемых для кодирования каждого пикселя. Оптимизация изображения сводится к уменьшения этих двух составляющих.

Таким образом, один из самых простых и эффективных методов оптимизации - убедиться, что размер отправляемого изображения не больше, чем его отображаемый размер в браузере. Ничего сложного, но многие сайты совершают серьезную ошибку. Они размещают крупные ресурсы, и браузеру приходится самому масштабировать и отображать их в более низком разрешении. Помимо всего прочего, это увеличивает нагрузку на процессор пользователя.

<table>
  
<thead>
  <tr>
    <th>Исходный размер</th>
    <th>Отображаемый размер</th>
    <th>Ненужные пиксели</th>
    <th>Unnecessary pixels</th>
  </tr>
</thead>

<tr>
  <td data-th="resolution">110 x 110</td>
  <td data-th="natural">100 x 100</td>
  <td data-th="display">110 x 110 - 100 x 100 = 2100</td>
  <td data-th="overhead">110 x 110 - 100 x 100 = 2100</td>
</tr>
<tr>
  <td data-th="resolution">410 x 410</td>
  <td data-th="natural">400 x 400</td>
  <td data-th="display">410 x 410 - 400 x 400 = 8100</td>
  <td data-th="overhead">410 x 410 - 400 x 400 = 8100</td>
</tr>
<tr>
  <td data-th="resolution">810 x 810</td>
  <td data-th="natural">800 x 800</td>
  <td data-th="display">810 x 810 - 800 x 800 = 16100</td>
  <td data-th="overhead">810 x 810 - 800 x 800 = 16100</td>
</tr>
<tr>
  <td data-th="resolution">2x</td>
  <td data-th="natural">220 x 220</td>
  <td data-th="display">100 x 100</td>
  <td data-th="overhead">220 x 220 - (2 x 100) x (2 x 100) = 8400</td>
</tr>
<tr>
  <td data-th="resolution">2x</td>
  <td data-th="natural">820 x 820</td>
  <td data-th="display">400 x 400</td>
  <td data-th="overhead">820 x 820 - (2 x 400) x (2 x 400) = 32400</td>
</tr>
<tr>
  <td data-th="resolution">2x</td>
  <td data-th="natural">1620 x 1620</td>
  <td data-th="display">800 x 800</td>
  <td data-th="overhead">1620 x 1620 - (2 x 800) x (2 x 800) = 64400</td>
</tr>
</table>

Note that in all of the cases above the display size is "only 10 CSS pixels smaller" than the required asset for each screen resolution. However, the number of extra pixels, and their associated overhead, rises rapidly as the display dimensions of the image increase! As a result, while you may not be able to guarantee that every single asset is delivered at the exact display size, **you should ensure that the number of unnecessary pixels is minimal, and that your large assets in particular are delivered as close as possible to their display size.**

## Список методов оптимизации

Note: Чтобы узнать исходный и отображаемый размеры изображения, наведите на него курсор в Инструментах разработчика Chrome. В примере выше мы скачиваем изображение размером 300x260 пикселей, однако при показе клиент уменьшает его до 245x212 пикселей.

Отправляя лишние пиксели и предоставляя браузеру самому масштабировать ресурс, мы упускаем возможность оптимизировать количество байтов, нужных для отрисовки страницы. Обратите внимание, что при масштабировании не только уменьшается количество пикселей, но и меняется исходный размер изображения.

* **Prefer vector formats:** vector images are resolution and scale independent, which makes them a perfect fit for the multi-device and high-resolution world.
* **Minify and compress SVG assets:** XML markup produced by most drawing applications often contains unnecessary metadata which can be removed; ensure that your servers are configured to apply GZIP compression for SVG assets.
* **Pick best raster image format:** determine your functional requirements and select the one that suits each particular asset.
* **Experiment with optimal quality settings for raster formats:** don't be afraid to dial down the "quality" settings, the results are often very good and byte savings are significant.
* **Remove unnecessary image metadata:** many raster images contain unnecessary metadata about the asset: geo information, camera information, and so on. Use appropriate tools to strip this data.
* **Serve scaled images:** resize images on the server and ensure that the "display" size is as close as possible to the "natural" size of the image. Pay close attention to large images in particular, as they account for largest overhead when resized!
* **Automate, automate, automate:** invest into automated tools and infrastructure that will ensure that all of your image assets are always optimized.

## Feedback {: #feedback }

Обратите внимание, что во всех трех случаях отображаемый размер `всего лишь на 10 пикселей` меньше, чем исходный. Однако чем больше первоначальный размер изображения, тем больше лишних данных приходится кодировать и отправлять. Даже если вам не удастся установить полное совпадение исходного и отображаемого размеров, **вы должны максимально сократить количество ненужных пикселей.**