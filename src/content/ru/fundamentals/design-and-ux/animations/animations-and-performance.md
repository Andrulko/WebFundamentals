project_path: /web/_project.yaml book_path: /web/fundamentals/_book.yaml description: Анимация обязательно должна работать хорошо, в противном случае она испортит всю картину

{# wf_updated_on: 2014-10-20 #} {# wf_published_on: 2014-08-08 #}

# Анимация и производительность {: .page-title }

{% include "web/_shared/contributors/paullewis.html" %} {% include "web/_shared/contributors/samthorogood.html" %}

Частота кадров любой анимации должна составлять 60 кадров в секунду, поскольку пользователи заметят любые подвисания или задержки и воспримут это отрицательно

### TL;DR {: .hide-from-toc }

* Следите за тем, чтобы анимация не приводила к проблемам с производительностью, убедитесь в том, что знаете, как анимация того или иного свойства CSS повлияет на работу приложения.
* Анимация свойств, которые меняют геометрию (макет) страницы или вызывают ее фактическую перерисовку, особенно сильно сказывается на производительности.
* По возможности старайтесь менять свойства transform и opacity.
* Используйте свойство `will-change`, чтобы передать в браузер информацию о том, что планируется анимировать.

Анимация свойств сопряжена с затратой ресурсов, причем анимация одних свойств менее затратна, чем других. Например, при анимации свойств элемента `width` и `height` меняется его геометрия, в результате чего может измениться положение или размер других элементов на странице. Этот процесс называется перерасчетом макета (или, в браузерах на основе Gecko, таких как Firefox, – перерасчетом дерева отрисовки), и он может потребовать значительного объема ресурсов, если на странице много элементов. Каждый раз, когда вызывается перерасчет макета, как правило, выполняется фактическая перерисовка всей страницы или ее части, на что зачастую требуется даже больше ресурсов, чем на саму операцию перерасчета.

По возможности следует избегать анимации свойств, которые вызывают перерасчет макета или перерисовку. Для большинства современных браузеров это означает, что анимацию следует выполнять только в отношении свойств `opacity` и `transform`, которые браузер может оптимизировать в очень высокой степени, вне зависимости от того, какими средствами выполняется анимация (JavaScript или CSS).

Полный список действий, вызываемых отдельными свойствами CSS, приведен в разделе [Срабатывание событий при изменении CSS](http://csstriggers.com), также имеется полное руководство по созданию [высокопроизводительной анимации в HTML5](http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/).

### Использование свойства will-change

{# include shared/related_guides.liquid inline=true list=page.related-guides.blocking-css #}

Рекомендуется использовать свойство [`will-change`](http://dev.w3.org/csswg/css-will-change/), чтобы передать в браузер информацию о том, что вы намерены изменить свойство элемента. Это позволяет браузеру предпринять наиболее подходящие шаги по оптимизации еще до того, как изменение будет выполнено. Однако не следует использовать свойство `will-change` слишком часто, поскольку из-за этого браузер может впустую тратить ресурсы, что, в свою очередь, вызовет еще больше проблем с производительностью.

    .box {
      will-change: transform, opacity;
    }
    

В общем, железное правило заключается в том, что, если анимация может быть вызвана в следующие 200 мс (действием пользователя или из-за состояния приложения), то для анимируемых элементов правильно будет использовать свойство will-change. Поэтому в большинстве случаев любой элемент в текущем представлении вашего приложения, который планируется анимировать, должен иметь свойство `will-change` для тех свойств, которые планируется изменить. Для образца, который мы использовали в предыдущих руководствах, добавление свойства `will-change` к свойствам transform и opacity выглядит следующим образом:

## Производительность при использовании CSS и JavaScript – что лучше?

Теперь браузеры, в которых реализована его поддержка (в настоящее время это Chrome, Firefox и Opera), предпримут шаги по его оптимизации с целью поддержки изменения или анимации этих свойств.

* CSS-based animations, and Web Animations where supported natively, are typically handled on a thread known as the "compositor thread". This is different from the browser's "main thread", where styling, layout, painting, and JavaScript are executed. This means that if the browser is running some expensive tasks on the main thread, these animations can keep going without being interrupted.

* Other changes to transforms and opacity can, in many cases, also be handled by the compositor thread.

* If any animation triggers paint, layout, or both, the "main thread" will be required to do work. This is true for both CSS- and JavaScript-based animations, and the overhead of layout or paint will likely dwarf any work associated with CSS or JavaScript execution, rendering the question moot.

В Интернете можно найти много статей и комментариев, в которых сравниваются достоинства анимации с помощью CSS и JavaScript с точки зрения производительности. Вот несколько полезных замечаний:

## Feedback {: #feedback }

Если вы желаете точно знать, что происходит при анимации того или иного свойства, подробные сведения об этом см. в разделе [Срабатывание событий при изменении CSS](http://csstriggers.com).